{
  "name": "syringejs",
  "description": "An ultra-lightweight dependency injection framework for JavaScript",
  "url": "https://holt.org/gitprojects",
  "author": {
    "name": "Michael Holt",
    "email": "mike@holt.org"
  },
  "version": "0.6.0",
  "main": "syringe.min",
  "keywords": [
    "syringe",
    "injection",
    "ioc",
    "dependency",
    "inversion",
    "javascript",
    "currying"
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/holt/syringe.git"
  },
  "readme": "# syringe.js [![Build Status](https://travis-ci.org/holt/syringe.png)](https://travis-ci.org/holt/syringe) #\n\n<img src=\"https://github.com/holt/syringe/blob/master/img/syringe.png?raw=true\" align=\"right\" title=\"# Just a little pin prick ... there'll be no more AAAAAAAAH!\"/>\n\nSyringe is a teeny-tiny JavaScript dependency injection framework that allows you to dynamically assign data contracts to your functions, constructor functions, and methods. No more worrying about passing information directly, indirectly, or relying on the lexical scope as Syringe can vaccinate your operations ahead of time!\n\nNow, let's roll up our sleeves and begin shall we?\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Questions](#questions)\n- [Installation](#installation)\n- [API](#api)\n- [Examples](#examples)\n- [License](#license)\n\n## Overview ##\n\nSyringe works by taking a function and inoculating it with deep or shallow references to data items located within a data registry. When a syringed function executes, the references are reconciled against the registry and the _actual_ data items are passed to the function automatically.\n\n### A Simple Example\n\nFirst, create a new `Syringe` object instance:\n\n```javascript\nvar syr = Syringe.create({\n    'data': {\n        '00000': {\n            'name'      : 'Slothrop, Tyrone',\n            'rank'      : 'Lieutenant',\n            'locale'    : 'GB',\n            'division'  : 'ACHTUNG'\n        }\n    }\n});\n```\n\nNow define a simple _getter_ method and add it to the Syringe object registry. As part of this registration, we also specify that we want the `data` object to be injected\ninto the getter when it is invoked:\n\n```javascript\nsyr.add('utils.get', function (data, id) {\n\n    'use strict';\n\n    if (data = data[id] || false) {\n        data.msg = ''\n            + 'ID: '            + id\n            + '; Rank: '        + data.rank     || 'N/A'\n            + '; Division: '    + data.division || 'N/A';\n    }\n\n    return data;\n}, ['data']);\n```\n**Note:** The `data` _parameter_ could actually be called anything (for example, `d` or `staff`) - it doesn't have to match the name of the injected object.\n\nLet's create a simple utility function into which, on invocation, the getter is injected:\n\n```javascript\nsyr.on('log', ['utils.get'], function (get, id) {\n\n    'use strict';\n\n    return (get = get(id))\n        ? (console.info('Schwarzger채t accessed by \"' + get.name + '\"\\n' + get.msg), get)\n        : false;\n});\n```\n\nNow call the utility function with Slothrop's ID:\n\n```javascript\nlog('00000');   // Logs:\n                //      Schwarzger채t accessed by \"Slothrop, Tyrone\"\n                //      ID: 00000; Rank: Lieutenant; Division: ACHTUNG\n\n                // Returns:\n                //      {\n                //          'name'      : 'Slothrop, Tyrone',\n                //          'rank'      : 'Lieutenant',\n                //          'locale'    : 'GB',\n                //          'division'  : 'ACHTUNG',\n                //          'msg'       : 'ID: 00000; Rank: Lieutenant; Division: ACHTUNG'\n                //      }\n```\n\nThe logging utility returns some useful information and logs out a message to the console.\n\n### What Just Happened?\n\n The `log` function definition doesn't contain any _direct_ references to which getter method should be used or where the staff data is stored as the `get` method is passed into `log` by injection. When `get` is executed the `data` object is passed into `get` automatically. Thus, invoking `log` completes an injection contract between the three entities: `data`, `get`, and `log`.\n\nLoose coupling between the concerns means that we can easily change the registry data for the injected items. Let's add a custom warning message:\n\n```javascript\nsyr.add({\n    'warnings': {\n        'access': {\n            'success'   : '{0} is A-OK!',\n            'fail'      : '{0} does not have the proper authorization!'\n        }\n    }\n});\n```\n... modify the getter to check the data:\n\n```javascript\nsyr.set('utils.get', function (data, access, id) {\n\n    'use strict';\n\n    if (data = data[id] || false) {\n        var action = (data.rank !== 'General') ? 'fail' : 'success';\n        data.msg = access[action].replace('{0}', 'ID ' + id);\n    }\n\n    return data;\n}, ['data', 'warnings.access']);\n\n```\n\n... and call the utility function again:\n\n\n```javascript\nlog('00000');   // Logs:\n                //      Schwarzger채t accessed by \"Slothrop, Tyrone\"\n                //      ID 00000 does not have the proper authorization!\n                // ...\n```\n\nChange Slothrop's rank:\n\n```javascript\nsyr.set('data.00000.rank', 'General');\n```\n... and call the utility function again:\n\n```javascript\nlog('00000');   // Logs:\n                //      Schwarzger채t accessed by \"Slothrop, Tyrone\"\n                //      ID 00000 is A-OK!\n                // ...\n```\n\n## Questions\n\n### \"Does injection work with constructor functions?\"\n\nIndeed it does, and we can demonstrate this with another simple example. Create a data object:\n\n```javascript\nvar syr = Syringe.create({\n    'data': {\n        '00000': {\n            'name'      : 'Slothrop, Tyrone',\n            'rank'      : 'Lieutenant',\n            'locale'    : 'GB',\n            'division'  : 'ACHTUNG'\n        },\n        '00001': {\n            'name'      : 'Mucker-Maffick, Oliver',\n            'rank'      : 'Lieutenant',\n            'locale'    : 'GB',\n            'division'  : 'ACHTUNG'\n        }\n    }\n});\n```\nCreate a simple constructor that automatically adds `data` to its context:\n```javascript\nvar StaffObj = function (data, id) {\n\n    'use strict';\n\n    data = data || {};\n\n    if (({}).toString.call(data[id]) === '[object Object]') {\n        for (var prop in data[id]) {\n            if (data[id].hasOwnProperty(prop)) {\n                this[prop] = data[id][prop];\n            }\n        }\n    }\n};\n```\nBind the `data` object to the constructor:\n```javascript\nStaffObj = syr.on(['data'], StaffObj);\n```\n... and create a couple of new objects:\n```javascript\nvar slothrop = new StaffObj('00000');   // Creates:\n                                        //      {\n                                        //          \"name\"    : \"Slothrop, Tyrone\",\n                                        //          \"rank\"    : \"Lieutenant\",\n                                        //          \"locale\"  : \"GB\",\n                                        //          \"division\": \"ACHTUNG\"\n                                        //      }\n\nvar tantivy = new StaffObj('00001');    // Creates:\n                                        //      {\n                                        //          \"name\"    : \"Mucker-Maffick, Oliver\",\n                                        //          \"rank\"    : \"Lieutenant\",\n                                        //          \"locale\"  : \"GB\",\n                                        //          \"division\": \"ACHTUNG\"\n                                        //      }\n```\n\n### \"Can I see a more complex example?\"\n\n[Here's a Todos application](http://holt.github.io/syringe-todos)<sup>+</sup> that uses Syringe dependency injection to construct collection and view objects and manage controller operations. You can view the source code for this app in the [syringe-todos](https://github.com/holt/syringe-todos) repo.\n\n<img src=\"https://github.com/holt/syringe/blob/master/img/todos.png?raw=true\" align=\"center\" title=\"What to do... what to do...\"/>\n\n<sup>+ CSS and images courtesy of the awesome [TodoMVC](http://todomvc.com) project</sup>\n\n### \"Aren't we just making a curry?\"\n\nWhen you [curry](https://en.wikipedia.org/wiki/Partial_application) a function you typically have some values in your hand before you create a version of the function that has some (or all) of those values partially applied to it. With Syringe, instead of actual values we bind pointers to a registry which is interrogated at execution time when the bound method is invoked.\n\nThis is very convenient because you can arbitrarily change the registry values for a parameter so that completely different data gets passed the next time your bound function gets called. To further labor the medical theme, it's as if the flu shot you received last Winter could be remotely updated throughout the year. Only minus the Nobel Prize, obviously.\n\nCurrying _does_ take place, just at a different point. Syringe curries _your_ bound function into a factory that examines the passed parameters and applies the corresponding registry values to your function when it is called.\n\n### \"What's this about a registry?\"\n\nThe registry is a closured dependency map unique to each Syringe object instance that holds all of the data items you're interested in automatically provisioning to your bound functions on invocation. You can provision objects, arrays, values, functions, strings, numbers, anything really. You can map to their values directly, or by reference.\n\n**Note:** The free arguments you pass to a *bound* function don't have to match the signature; this is consistent with ordinary JavaScript functions. However, the bound parameters are expected to exist in the registry when the bound function is invoked.\n\n### \"Why doesn't Syringe just use the function signature?\"\n\nSome JavaScript dependency injection tutorials and libraries out there describe or provide ways of deriving function dependencies by _inference_ - that is, by scraping the contents of the bound function's signature:\n\n```javascript\nvar f = function ($dep1, $dep2, freearg1, frearg2) { ... };\n\nInjection.bind(f);  // The library uses RegEx to figure out the parameters\n                    // of `f` in order to pull them from the data registry\n                    // and apply them to `f` when the function is executed\n```\n\nThere are a number of reasons why Syringe does not work this way, the main one being that parameters often get renamed when run through compression / obfuscation systems such as Google Closure or UglifyJS. This makes any subsequent reconciliation of the parameters against named items impossible.\n\nIn addition, unless you namespace the dependencies it is impossible to disambiguate them from the free arguments. Also, dot-notation is not allowed in parameter names so you end up using something goofy like `$leve1_level2_level3` to retrieve deep items.\n\n## Installation\n\n### Browser\n\nJust download [syringe.min.js](https://raw.github.com/holt/syringe/master/syringe.min.js) and add it to your to your environment.\n\n#### Dependencies\n\nSyringe uses `JSON.parse` and also the following ECMAScript 5 / JavaScript 1.6 methods:\n\n- `Array.filter`\n- `Array.map`\n- `Array.reduce`\n- `Function.bind`\n- `String.trim`\n- `Object.keys`\n- `Object.create`\n\nAll of the above methods are available natively on modern browsers. If you need to support older browsers, the polyfills for these methods are provided in [lib/polyfill.min.js](https://raw.github.com/holt/syringe/master/lib/polyfill.min.js)\n\n#### Compatibility\n\nSyringe has been tested on the following browsers:\n\n- Firefox 2+\n- Chrome 11+\n- Safari 3+\n- Opera 9+\n- Internet Explorer 7+\n\n### Node\n\nEnsure that you have installed the latest version of [node.js](http://nodejs.org) and run the following from the command prompt:\n\n`npm install syringejs`\n\n### Bower\n\nEnsure that you have installed the latest version of [Bower](http://bower.io/) and run the following from the command prompt:\n\n`bower install syringe --save`\n\n### NuGet\n\nRun the following command in the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console):\n\n`Install-Package syringe.js`\n\n## API ##\n\nThis following table describes the methods provided by the `Syringe` object:\n\nName     | Parameters   | Description\n---------|--------------|-------------\n*create* | `[map]` | Create a new syringe object. <br/><br/>**Example**: `var syr = Syringe.create();`\n*add*    | `name, value [, bindings]` | Register an item with the dependency map, where `name` is the dependency name and `value` is any valid JavaScript value. Alias: _register_. <br/><br/>**Example**: `syr.add('data', {'name': 'Mike'});`<br/><br/> If  `value` is a function that you want to automatically bind as a Syringe method, set the `bindings` property to the array of properties you want to inject. Alias: _register_. <br/><br/>**Example**: `syr.add('data', function (props) {...}, ['props']);`\n*add*    | `map`      | Register a map of dependencies, where `map` is an object. Alias: _register_. <br/><br/>**Example**: `syr.add({'data': {'name': 'Mike'}});`\n*add*    | `array`      | Register an array of map of dependencies, where each map is an object. Useful for asserting order when additions are functions that are side-effectful. Alias: _register_. <br/><br/>**Example**: `syr.add([{'data.name': 'Mike'}, {'data.age': '39'}]);`\n*remove* | `name`                   | Remove a named item from the dependency map. Alias: _unregister_. <br/><br/>**Example**: `syr.remove('data');`\n*remove* | `array`                   | Remove an array of named item from the dependency map. Alias: _unregister_. <br/><br/>**Example**: `syr.remove(['data', 'foo.bar']);`\n*on*     | `bindings, fn [, ctx]` | Return a bound function that can access the dependency map. An optional `ctx` parameter makes the bound function execute in a specific context. Alias: _bind_. <br/><br/>**Example**: `var f = syr.on(['data'], function (data) {...});` <br/><br/> If you want to bind the current Syringe object, use the keyword `this` instead of a keyname in the bindings array. <br/><br/>**Example**: `var f = syr.on(['this'], function (syr) {...});` <br/><br/> If you want to bind the _entire_ dependency map, use an asterisk (`*`) instead of a keyname in the bindings array. <br/><br/>**Example**: `var f = syr.on(['*'], function (map) {...});` <br/><br/> If you want to bind a shallow or deep item located _outside_ of the dependency map in the global object, use the prefix `global:` before the keyname in the bindings array. <br/><br/>**Example**: `var f = syr.on(['global:jQuery'], function ($) {..});`\n*on*     | `name, bindings, fn [, ctx]`| Bind a named function. The `name` string can be a character-delimited path; if the path doesn't exist it will be created dynamically as a nested object structure. An optional `ctx` parameter makes the bound function execute in a specific context. Alias: _bind_. <br/><br/>**Example**: `syr.on('f', ['data'], function (data) {...}, this);`\n*on* | `map` | Bind a named function to an optional target, or return an unnamed function. The `name` property can be a character-delimited path; if the path doesn't exist it will be created dynamically as a nested object structure. An optional `ctx` property makes the bound function execute in a specific context. Alias: _bind_. <br/><br/>**Example**: [See below](#creating-bound-functions-using-a-property-map)\n*get*    | `name` | Returns the named value from dependency map object. Dot-notation is permitted. Passing no argument returns the dependency map object. <br/><br/>**Example**: `syr.get('data');`\n*set*    | `name, value [, bindings]` | Directly sets the value of a named key in the dependency map, if it exists. <br/><br/>**Example**: `syr.set('data.name', 'Bob');`<br/><br/> If  `value` is a function that you want to automatically bind as a Syringe method, set the `bindings` property to the array of properties you want to inject.<br/><br/>**Example**: `syr.set('get', function (name) {...}, ['data.name']);`\n*exec*    | `name, args [, ctx]` | Directly execute a method within the dependency map. Provided as a convenience for occasions where binding isn't possible. An optional `ctx` parameter executes the method against a specified context. <br/><br/>**Example**: `syr.exec('f', ['Mike', '39']);`\n*fetch*  | `array, props` | Retrieve array-defined items asynchronously. Each array item is an object that contains a `path` property and a `bind` property. The `path` property is a string containing the (local) URI of the resource. The `bind` property specifies the Syringe key you want to associate with the JSON object retrieved from the resource.<br/><br/>**Note:** This method is only available in the browser.<br/><br/>**Example**: [See below](#register-items-asynchronously)\n*wrap*   | `fn, wrapper [, ctx]` | Wrap a bound method with another method in order to develop middleware. An optional `ctx` parameter adds the bound function to a specified context.<br/><br/>**Example**: [See below](#fibonacci-number-add-on-remove-wrap-get)\n*copy*   | `bindings, fn [, ctx]` | Create a new bound function from an existing one using a new dependency map binding. <br/><br/>**Example**: `var f2 = syr.copy(['data2'], f);`\n*mixin*   | `map` | Add mixin methods to the Syringe object prototype. <br/><br/>**Example**: `syr.mixin({'f': function () { return this; }});`\n*separator* | `value` | Change the name separator character used to create, retrieve, and bind objects. The default character is a period (`.`). The character must be non-alphanumeric. <br/><br/>**Example**: `syr.separator('#');`\n*listen* | `name, fn` | Binds a listener to a named Syringe method (`get`, `set`, `add`, or `remove`). Shallow or deep \npath namespacing is also supported. <br/><br/>**Example**: `syr.listen('add', function (name, value) {...});` <br/><br/>**Example**: `syr.listen('set:name', function (name, value) {...});`  <br/><br/>**Example**: `syr.listen('remove:data.name', function (name) {...});`\n\n### Creating Bound Functions Using a Property Map\n\nInstead of passing multiple arguments to `.on()`, functions can be bound using a property map object.\n\nProperty  | Description  | Example | Optional\n----------|--------------|---------|----------\n*name*    | A character delimited name for the bound function.<br/><br/>If a name but no `target` property is provided, the function is attached in shallow or deep form to the global object.<br/><br/>If a name and a `target` property is provided, the function is attached in shallow or deep form to the target object.<br/><br/>**Note:** If no name is provided, the bound function is returned as an anonymous function. | `first.second.third` | Yes\n*bindings*| An array of registry map items to be injected into the function specified by `fn`. | `['data', 'weather.report']` | No\n*fn*      | The function against which the injection operation takes place. Must have at least as many parameters as injected items. Any additional parameters are treated as free arguments that are passed by the caller on invocation. | `function (data, report) {...}` | No\n*ctx*     | The `this` context in which the function specified by `fn` will execute. | `{'foo': 'bar'}` | Yes\n*target*  | The target into which a named bound function can be attached. If the function isn't named, this property has no effect. | `window.utils` | Yes\n\nHere's a simple example. Add a an empty target:\n\n```javascript\nwindow.utils = {};\n```\nAdd some data to the registry:\n```javascript\nSyringe.add({\n    data: 'example data',\n    weather: {\n        report: 'sunny'\n    }\n})\n```\nCreate a simple function:\n```javascript\nvar fn = function (data, report) {\n    console.log('Here is some ' + data);\n    console.log('The weather is ' + report);\n    console.log('Let\\'s go to the ' + this.foo);\n};\n```\nBind the function as a named function that executes with a provided context and gets added to a specified target:\n```javascript\nSyringe.on({\n    name    : 'first.second.third',\n    bindings: ['data', 'weather.report'],\n    fn      : fn,\n    ctx     : {'foo': 'bar'},\n    target  : window.utils\n});\n```\nExecute the bound function:\n```javascript\nwindow.utils.first.second.third();  //  Logs:\n                                    //      Here is some example data\n                                    //      The weather is sunny\n                                    //      Let's go to the bar\n```\n\n### Register Items Asynchronously\n\nYou can retrieve JSON data items from a remote source and add them to the Syringe registry using the `fetch` method:\n\n```javascript\nsyr.fetch([{\n    path: '/syringe/test1',\n    bind: 'data1'\n}, {\n    path: '/syringe/test2',\n    bind: 'data2'\n}], {\n    'success': function () {\n        console.log(this.get('data1'));\n        console.log(this.get('data2'));\n    }\n});\n```\n\n\n## Examples ##\n\nThe following generic examples show how some of the API methods provided by Syringe might be used to manage function operations.\n\n### FizzBuzz (add, bind, exec, remove) ###\n\nA FizzBuzz is a program that prints the numbers from 1 to 100. But for multiples of three it prints `Fizz` instead of the number. For multiples of five it prints `Buzz`. For numbers which are multiples of both three and five it prints `FizzBuzz`. It's also a drinking game, and a surprisingly tricky one.\n\n```javascript\nSyringe.add('fn', function (syr, fn, lg, n) {\n\n    // Examine the passed integer and log the evaluation\n    n = n || 1, lg((n % 3?'':'Fizz')+(n % 5?'':'Buzz') || n);\n\n    // Execute against self with current integer or remove self\n    return (100 >= ++n ? fn(n) : syr.remove('fn'));\n\n}, ['this', 'fn', 'global:console.log']);\n\n// Execute the function:\nSyringe.exec('fn');\n```\n\nThe above code shows how a simple functional FizzBuzz can be created with Syringe, and illustrates a number of different qualities. The first is obviously recursion - a function can inject itself into itself when executed.\n\nThe bound function also receives its action (in this case a logger from the `global:` context) as a passed parameter, which decouples side-effectful operations from the main operation slightly. When the function completes, it removes itself from the dependency map and returns the Syringe object.\n\n### Sieve Of Eratosthenes (add, bind, on, copy) ###\n\nThe sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (that is, not prime) the multiples of each prime, starting with all multiples of 2. \n\nFor this example we're going to implement two slightly different ways of recursively processing the data and see which one is more performant. First we create a processor that sieves the data using `reduce`:\n\n```javascript\nSyringe.add('reduce', function (proc, arr, cnt) {\n\n    if ((cnt = cnt || 1) > Math.sqrt(arr.length)) {\n        return 1 === arr[0] && arr.shift(), arr;\n    }\n\n    return proc(arr.reduce(function (prv, cur, idx, lst) {\n        0 === cur % lst[cnt] && cur !== lst[cnt] || prv.push(cur);\n        return prv;\n    }, []), ++cnt);\n\n}, ['reduce']);\n```\n\nNext we create an alternate processor that sieves the data using an incrementing `while` loop:\n\n```javascript\nSyringe.add('while', function (proc, arr, cnt) {\n\n    var len = 0, newarr = [];\n\n    if ((cnt = cnt || 1) > Math.sqrt(arr.length)) {\n        return 1 === arr[0] && arr.shift(), arr;\n    }\n   \n    while (len < arr.length) {\n        arr[len] % arr[cnt] === 0 && arr[len] !== arr[cnt] || newarr.push(arr[len])        \n        len++;\n    }\n\n    return proc(newarr, ++cnt);\n\n}, ['while']);\n```\n\nNow we create a sieving function that builds the seed array and passes it to the `while` processor:\n\n```javascript\nvar sieve_while = Syringe.on(['while'], function (proc, to) {\n\n    to = to || 10;\n    var n = 1, arr = [];\n    while (to--) arr[to] = n++;      \n\n    return proc(arr.reverse());\n\n});\n```\n\nWe can copy `sieve_while` and create an alternate sieving function that uses the `reduce` processor:\n\n```javascript\nvar sieve_reduce = Syringe.copy(['reduce'], sieve_while);\n```\n\nFinally, let's ask both to return all prime numbers between 1 and 10,000 and see what happens:\n\n```javascript\nconsole.time('sieve while');\n\nconsole.log(sieve_while(10000));    // Logs:\n                                    //      [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41 ... ]\nconsole.timeEnd('sieve while');     // Logs:\n                                    //      sieve while: 80ms\n\n\nconsole.time('sieve reduce');\n\nconsole.log(sieve_reduce(10000));   // Logs:\n                                    //      [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41 ... ]\n\nconsole.timeEnd('sieve reduce');    // Logs:\n                                    //      sieve reduce: 120ms\n```\n\nThe `while` processor appears to be considerably more performant!\n\n###  Fibonacci Number (add, on, remove, wrap, get)\n\nThe Fibonacci sequence is a numeric list where the first two numbers are 0 and 1 and each subsequent number is the sum of the previous two. The following example describes a simple function that calculates the Fibonacci value of a specific number.\n\n```javascript\nvar fib = function () {\n    var fn = Syringe.on(['store'], function (store, a) {\n        var res = store[a];\n        if ('number' !== typeof res) {\n            res = fn(a - 1) + fn(a - 2);\n            store[a] = res;\n        }\n        return res;\n    });\n    return fn;\n}();\n```\n\nTo improve performance, the storage of each preceding number is held inside the dependency map:\n\n```javascript\nSyringe.add('store', [0, 1]);\n```\n\nIn the Sieve Of Eratosthenes example we bookended the bound function with a console timer to determine the overall performance of the operation. In this example we'll use Syringe to wrap our bound function with a timer in order to produce a new function:\n\n```javascript\nfib = Syringe.wrap(fib, function (fn, num, name) {\n\n    var start, stop, ret;\n\n    start   = (new Date()).getTime();\n    ret     = fn();\n    stop    = (new Date()).getTime();\n\n    this.remove('log.' + name)\n        .add('log.' + name, 'The ' + name + ' function took ' + (stop - start) + 'ms');\n\n    return ret;\n});\n```\n\nNow we execute the function, providing an argument that specifies the number for which we want know the Fibonacci value, and the name of the function for logging purposes:\n\n```javascript\nfib(100, 'fib');    // Returns:\n                    //      55\n\nSyringe.get('log'); // Returns: \n                    //      {\n                    //          fib: \"The fib function took 11ms\"\n                    //      }\n```\n\n## License\n\nSyringe is freely distributable under the terms of the MIT license.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/holt/syringe/issues"
  },
  "homepage": "https://github.com/holt/syringe",
  "_id": "syringejs@0.6.0",
  "_from": "syringejs@"
}
